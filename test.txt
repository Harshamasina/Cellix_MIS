const express = require("express");
const MongoClient = require("mongodb").MongoClient;
const firebaseAdmin = require("firebase-admin");

const app = express();
const port = 3000;

// Initialize Firebase Admin SDK
firebaseAdmin.initializeApp({
  credential: firebaseAdmin.credential.applicationDefault(),
  databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
});

// Connect to MongoDB
const uri = "mongodb+srv://<user>:<password>@cluster0.mongodb.net/test?retryWrites=true&w=majority";
const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
client.connect(err => {
  if (err) throw err;
  console.log("MongoDB connected!");
});

// Login Route
app.post("/login", (req, res) => {
  // Implement Firebase Auth to authenticate the user
  firebaseAdmin
    .auth()
    .verifyIdToken(req.body.idToken)
    .then(decodedToken => {
      // Get the user data from the decoded token
      const user = decodedToken.user_id;
      // Check if the user exists in the MongoDB database
      client.db("test").collection("users").findOne({ user }, (err, result) => {
        if (err) throw err;
        if (result) {
          res.send({ message: "User authenticated", user });
        } else {
          res.status(401).send({ message: "User not found" });
        }
      });
    })
    .catch(error => {
      res.status(401).send({ message: "Invalid token", error });
    });
});

// Signup Route
app.post("/signup", (req, res) => {
  // Implement Firebase Auth to create a new user
  firebaseAdmin
    .auth()
    .createUser({
      email: req.body.email,
      password: req.body.password
    })
    .then(userRecord => {
      // Get the user data from the user record
      const user = userRecord.uid;
      // Insert the user data into the MongoDB database
      client.db("test").collection("users").insertOne({ user }, (err, result) => {
        if (err) throw err;
        res.send({ message: "User created", user });
      });
    })
    .catch(error => {
      res.status(400).send({ message: "Error creating user", error });
    });
});

// CRUD Operations

// Create Route
app.post("/create", (req, res) => {
  // Insert the data into the MongoDB database
  client.db("test").collection("items").insertOne(req.body, (err, result) => {
    if (err) throw err;
    res.send({ message: "Item created", item: result.ops[0] });
  });
});

// Read Route
app.get("/read/:id", (req, res) => {
  // Find the item in the MongoDB database
  client.db("test").collection("items").findOne({ _id: req.params.id }, (err, result) => {
    if (err) throw err;
    if (result) {
      res.send({ message: "Item found", item: result });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

// Update Route
app.put("/update/:id", (req, res) => {
  // Update the item in the MongoDB database
  client.db("test").collection("items").updateOne({ _id: req.params.id }, { $set: req.body }, (err, result) => {
    if (err) throw err;
    if (result.modifiedCount > 0) {
      res.send({ message: "Item updated" });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

// Delete Route
app.delete("/delete/:id", (req, res) => {
  // Delete the item from the MongoDB database
  client.db("test").collection("items").deleteOne({ _id: req.params.id }, (err, result) => {
    if (err) throw err;
    if (result.deletedCount > 0) {
      res.send({ message: "Item deleted" });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

app.listen(port, () => {
  console.log(`App listening at http://localhost:${port}`);
});



const functions = require("firebase-functions");
const admin = require("firebase-admin");
const nodemailer = require("nodemailer");
const crypto = require("crypto");
const jwt = require("jsonwebtoken");

admin.initializeApp();

// Generate OTP function
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000);
}

// Send OTP function
async function sendOTP(email, OTP) {
  let transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 587,
    secure: false,
    auth: {
      user: "<email>",
      pass: "<password>"
    }
  });

  let mailOptions = {
    from: "<email>",
    to: email,
    subject: "OTP for Login",
    text: `Your OTP for Login is ${OTP}`
  };

  await transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.log(error);
    } else {
      console.log("Email sent: " + info.response);
    }
  });
}

// Verify OTP function
async function verifyOTP(email, OTP) {
  let user = await admin.auth().getUserByEmail(email);
  if (user.customClaims && user.customClaims.OTP && user.customClaims.OTP === OTP) {
    return true;
  }
  return false;
}

// Login Route
exports.login = functions.https.onRequest(async (req, res) => {
  // Check if the email exists in the database
  let user = await admin.auth().getUserByEmail(req.body.email);
  if (!user) {
    return res.status(400).send({ message: "Email not found" });
  }

  // Generate and send the OTP
  let OTP = generateOTP();
  await sendOTP(req.body.email, OTP);

  // Store the OTP in the user's custom claims
  await admin.auth().setCustomUserClaims(user.uid, { OTP: OTP });

  // Return a message to enter the OTP
  res.send({ message: "OTP sent. Please check your email." });
});

// Verify OTP Route
exports.verifyotp = functions.https.onRequest(async (req, res) => {
  // Check if the OTP is correct
  let verified = await verifyOTP(req.body.email, req.body.OTP);
  if (!verified) {
    return res.status(400).send({ message: "OTP incorrect" });
  }

  // Remove the OTP from the user's custom claims
  let user = await admin.auth().getUserByEmail(req.body.email);
  await admin.auth().setCustomUserClaims(user.uid, {});

  // Generate a JWT token

  const expiresIn = 2 * 60 * 60; // 2 hours
  const secret = "<secret-key>";
  const token = jwt.sign({ email: req.body.email }, secret, { expiresIn });

  // Return the JWT token to the client
  res.send({ token });
});

// Middleware to verify the JWT token
function verifyToken(req, res, next) {
  const bearerHeader = req.headers["authorization"];
  if (typeof bearerHeader !== "undefined") {
    const bearer = bearerHeader.split(" ");
    const bearerToken = bearer[1];
    req.token = bearerToken;
    next();
  } else {
    res.sendStatus(401);
  }
}

// Route to access protected resources
exports.protected = functions.https.onRequest((req, res) => {
  jwt.verify(req.token, "<secret-key>", (err, data) => {
    if (err) {
      res.sendStatus(401);
    } else {
      // Access granted
      res.send({ message: "Access granted", data: data });
    }
  });
});

<USING WITHOUT FIREBASE>

// Import the required packages
const nodemailer = require("nodemailer");
const crypto = require("crypto");

// Generate OTP function
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000);
}

// Send OTP function
async function sendOTP(email, OTP) {
  let transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 587,
    secure: false,
    auth: {
      user: "<email>",
      pass: "<password>"
    }
  });

  let mailOptions = {
    from: "<email>",
    to: email,
    subject: "OTP for Login",
    text: `Your OTP for Login is ${OTP}`
  };

  await transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.log(error);
    } else {
      console.log("Email sent: " + info.response);
    }
  });
}

// Login Route
app.post("/login", async (req, res) => {
  // Check if the email exists in the database
  let user = await client.db("test").collection("users").findOne({ email: req.body.email });
  if (!user) {
    return res.status(400).send({ message: "Email not found" });
  }

  // Generate and send the OTP
  let OTP = generateOTP();
  await sendOTP(req.body.email, OTP);

  // Store the OTP in the database
  await client.db("test").collection("users").updateOne({ email: req.body.email }, { $set: { OTP: OTP } });

  // Return a message to enter the OTP
  res.send({ message: "OTP sent. Please check your email." });
});

// Verify OTP Route
app.post("/verifyotp", async (req, res) => {
  // Check if the OTP is correct
  let user = await client.db("test").collection("users").findOne({ email: req.body.email, OTP: req.body.OTP });
  if (!user) {
    return res.status(400).send({ message: "OTP incorrect" });
  }

  // Remove the OTP from the database
  await client.db("test").collection("users").updateOne({ email: req.body.email }, { $unset: { OTP: "" } });

  // Generate a JWT token
  let token = jwt.sign({ email: req.body.email }, "<secret>", { expiresIn: "1h" });

  // Return the JWT token
  res.send({ message: "OTP verified", token: token });
});




            const filteredArray = docs.filter((doc) => {
            const diffDays1 =  getDifferenceInDays(currentDate, new Date(doc.prv_dof));
            const diffDays2 =  getDifferenceInDays(currentDate, new Date(doc.pct_dof));
            if(diffDays1 <= 60 || diffDays2 <= 60){
                return true;
            }
            const npeDates = doc.npe.map((npeDate) => {
                return npeDate.npe_dof;
            }).concat(doc.npe.map((npeData) => {
                return npeData.npe_grant;
            }));
            for(const npeFieldDate of npeDates ){
                const diffDays = getDifferenceInDays(currentDate, new Date(npeFieldDate));
                if(diffDays <= 60){
                    return true;
                }
            }
            return false;
        });
        // const sortedArray = filteredArray.sort((a, b) => {
        //     const diffDays1 = getDifferenceInDays(currentDate, a.prv_dof);
        //     const diffInDays2 = getDifferenceInDays(currentDate, a.pct_dof);
        //     let nestedDiffA = 0;
        //     a.npe.forEach((subdoc) => {
        //         nestedDiffA += getDifferenceInDays(currentDate, subdoc.npe_dof);
        //         nestedDiffA += getDifferenceInDays(currentDate, subdoc.npe_grant);
        //     });
        //     const totalDiffA = diffDays1 + diffInDays2 + nestedDiffA;
        //     const diffInDays3 = getDifferenceInDays(today, b.prv_dof);
        //     const diffInDays4 = getDifferenceInDays(today, b.pct_dof);
        //     let nestedDiffB = 0;
        //     b.subfield4.forEach((subdoc) => {
        //         nestedDiffB += getDifferenceInDays(today, subdoc.npe_dof);
        //         nestedDiffB += getDifferenceInDays(today, subdoc.npe_grant);
        //     });
        //     const totalDiffB = diffInDays3 + diffInDays4 + nestedDiffB;
        //     return totalDiffA - totalDiffB;
        // });
        console.log(filteredArray.length);
        res.json(filteredArray);


        const sortedArray = filteredArray.map((obj) => {
            const newObj = {
              fieldName: '',
              fieldValue: '',
            };
            obj.npe.forEach((subfield) => {
              const dateField3 = new Date(subfield.npe_dof);
              const dateField4 = new Date(subfield.npe_grant);
              newObj.fieldName = 'npe_dof';
              newObj.fieldValue = subfield.dateField3;
              if (getDifferenceInDays(currentDate, dateField3) <= 60) {
                return newObj;
              }
              newObj.fieldName = 'dateField4';
              newObj.fieldValue = subfield.npe_grant;
              if (getDifferenceInDays(currentDate, dateField4) <= 60) {
                return newObj;
              }
            });
      
            const dateField1 = new Date(obj.prv_dof);
            const dateField2 = new Date(obj.pct_dof);
            if (getDifferenceInDays(currentDate, dateField1) <= 60) {
              newObj.fieldName = 'prv_dof';
              newObj.fieldValue = obj.dateField1;
              return newObj;
            } else if (getDifferenceInDays(currentDate, dateField2) <= 60) {
              newObj.fieldName = 'pct_dof';
              newObj.fieldValue = obj.dateField2;
              return newObj;
            }
            return newObj;
        });
        res.json(sortedArray);


        const filteredArray = data.filter((obj) => {
            let isWithinTwoMonths = false;
            obj.npe.forEach((subfield) => {
              const dateField3 = new Date(subfield.npe_appno);
              const dateField4 = new Date(subfield.npe_grant);
              const dateField1 = new Date(obj.prv_dof);
              const dateField2 = new Date(obj.pct_dof);
                
              if (
                getDifferenceInDays(currentDate, dateField3) <= 60 ||
                getDifferenceInDays(currentDate, dateField4) <= 60 ||
                getDifferenceInDays(currentDate, dateField1) <= 60 ||
                getDifferenceInDays(currentDate, dateField2) <= 60
              ) {
                isWithinTwoMonths = true;
              }
            });
            return isWithinTwoMonths;
        });




        

        const { wno, pct, year, therapeutic_area, publication_date, diseases, claims, formulas, compounds } = req.body;
        if( !wno || !pct || !year || !therapeutic_area || !publication_date || !diseases ){
            return res.status(400).json({
                message: "wno, pct, year, therapeutic_area, publication_date are mandatory"
            });
        }
        const existingPatent = await patentSchema.find({ wno, pct });
        if(existingPatent){
            return res.status(409).json({
                message: "Patent Already Exists"
            });
        }
        const patent = new patent({ wno, pct, year, therapeutic_area, publication_date, diseases, claims, formulas, compounds });
        const newPatent = await patent.save();
        res.status(201).json(newPatent);