const express = require("express");
const MongoClient = require("mongodb").MongoClient;
const firebaseAdmin = require("firebase-admin");

const app = express();
const port = 3000;

// Initialize Firebase Admin SDK
firebaseAdmin.initializeApp({
  credential: firebaseAdmin.credential.applicationDefault(),
  databaseURL: "https://<DATABASE_NAME>.firebaseio.com"
});

// Connect to MongoDB
const uri = "mongodb+srv://<user>:<password>@cluster0.mongodb.net/test?retryWrites=true&w=majority";
const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
client.connect(err => {
  if (err) throw err;
  console.log("MongoDB connected!");
});

// Login Route
app.post("/login", (req, res) => {
  // Implement Firebase Auth to authenticate the user
  firebaseAdmin
    .auth()
    .verifyIdToken(req.body.idToken)
    .then(decodedToken => {
      // Get the user data from the decoded token
      const user = decodedToken.user_id;
      // Check if the user exists in the MongoDB database
      client.db("test").collection("users").findOne({ user }, (err, result) => {
        if (err) throw err;
        if (result) {
          res.send({ message: "User authenticated", user });
        } else {
          res.status(401).send({ message: "User not found" });
        }
      });
    })
    .catch(error => {
      res.status(401).send({ message: "Invalid token", error });
    });
});

// Signup Route
app.post("/signup", (req, res) => {
  // Implement Firebase Auth to create a new user
  firebaseAdmin
    .auth()
    .createUser({
      email: req.body.email,
      password: req.body.password
    })
    .then(userRecord => {
      // Get the user data from the user record
      const user = userRecord.uid;
      // Insert the user data into the MongoDB database
      client.db("test").collection("users").insertOne({ user }, (err, result) => {
        if (err) throw err;
        res.send({ message: "User created", user });
      });
    })
    .catch(error => {
      res.status(400).send({ message: "Error creating user", error });
    });
});

// CRUD Operations

// Create Route
app.post("/create", (req, res) => {
  // Insert the data into the MongoDB database
  client.db("test").collection("items").insertOne(req.body, (err, result) => {
    if (err) throw err;
    res.send({ message: "Item created", item: result.ops[0] });
  });
});

// Read Route
app.get("/read/:id", (req, res) => {
  // Find the item in the MongoDB database
  client.db("test").collection("items").findOne({ _id: req.params.id }, (err, result) => {
    if (err) throw err;
    if (result) {
      res.send({ message: "Item found", item: result });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

// Update Route
app.put("/update/:id", (req, res) => {
  // Update the item in the MongoDB database
  client.db("test").collection("items").updateOne({ _id: req.params.id }, { $set: req.body }, (err, result) => {
    if (err) throw err;
    if (result.modifiedCount > 0) {
      res.send({ message: "Item updated" });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

// Delete Route
app.delete("/delete/:id", (req, res) => {
  // Delete the item from the MongoDB database
  client.db("test").collection("items").deleteOne({ _id: req.params.id }, (err, result) => {
    if (err) throw err;
    if (result.deletedCount > 0) {
      res.send({ message: "Item deleted" });
    } else {
      res.status(404).send({ message: "Item not found" });
    }
  });
});

app.listen(port, () => {
  console.log(`App listening at http://localhost:${port}`);
});



const functions = require("firebase-functions");
const admin = require("firebase-admin");
const nodemailer = require("nodemailer");
const crypto = require("crypto");
const jwt = require("jsonwebtoken");

admin.initializeApp();

// Generate OTP function
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000);
}

// Send OTP function
async function sendOTP(email, OTP) {
  let transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 587,
    secure: false,
    auth: {
      user: "<email>",
      pass: "<password>"
    }
  });

  let mailOptions = {
    from: "<email>",
    to: email,
    subject: "OTP for Login",
    text: `Your OTP for Login is ${OTP}`
  };

  await transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.log(error);
    } else {
      console.log("Email sent: " + info.response);
    }
  });
}

// Verify OTP function
async function verifyOTP(email, OTP) {
  let user = await admin.auth().getUserByEmail(email);
  if (user.customClaims && user.customClaims.OTP && user.customClaims.OTP === OTP) {
    return true;
  }
  return false;
}

// Login Route
exports.login = functions.https.onRequest(async (req, res) => {
  // Check if the email exists in the database
  let user = await admin.auth().getUserByEmail(req.body.email);
  if (!user) {
    return res.status(400).send({ message: "Email not found" });
  }

  // Generate and send the OTP
  let OTP = generateOTP();
  await sendOTP(req.body.email, OTP);

  // Store the OTP in the user's custom claims
  await admin.auth().setCustomUserClaims(user.uid, { OTP: OTP });

  // Return a message to enter the OTP
  res.send({ message: "OTP sent. Please check your email." });
});

// Verify OTP Route
exports.verifyotp = functions.https.onRequest(async (req, res) => {
  // Check if the OTP is correct
  let verified = await verifyOTP(req.body.email, req.body.OTP);
  if (!verified) {
    return res.status(400).send({ message: "OTP incorrect" });
  }

  // Remove the OTP from the user's custom claims
  let user = await admin.auth().getUserByEmail(req.body.email);
  await admin.auth().setCustomUserClaims(user.uid, {});

  // Generate a JWT token

  const expiresIn = 2 * 60 * 60; // 2 hours
  const secret = "<secret-key>";
  const token = jwt.sign({ email: req.body.email }, secret, { expiresIn });

  // Return the JWT token to the client
  res.send({ token });
});

// Middleware to verify the JWT token
function verifyToken(req, res, next) {
  const bearerHeader = req.headers["authorization"];
  if (typeof bearerHeader !== "undefined") {
    const bearer = bearerHeader.split(" ");
    const bearerToken = bearer[1];
    req.token = bearerToken;
    next();
  } else {
    res.sendStatus(401);
  }
}

// Route to access protected resources
exports.protected = functions.https.onRequest((req, res) => {
  jwt.verify(req.token, "<secret-key>", (err, data) => {
    if (err) {
      res.sendStatus(401);
    } else {
      // Access granted
      res.send({ message: "Access granted", data: data });
    }
  });
});

<USING WITHOUT FIREBASE>

// Import the required packages
const nodemailer = require("nodemailer");
const crypto = require("crypto");

// Generate OTP function
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000);
}

// Send OTP function
async function sendOTP(email, OTP) {
  let transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 587,
    secure: false,
    auth: {
      user: "<email>",
      pass: "<password>"
    }
  });

  let mailOptions = {
    from: "<email>",
    to: email,
    subject: "OTP for Login",
    text: `Your OTP for Login is ${OTP}`
  };

  await transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.log(error);
    } else {
      console.log("Email sent: " + info.response);
    }
  });
}

// Login Route
app.post("/login", async (req, res) => {
  // Check if the email exists in the database
  let user = await client.db("test").collection("users").findOne({ email: req.body.email });
  if (!user) {
    return res.status(400).send({ message: "Email not found" });
  }

  // Generate and send the OTP
  let OTP = generateOTP();
  await sendOTP(req.body.email, OTP);

  // Store the OTP in the database
  await client.db("test").collection("users").updateOne({ email: req.body.email }, { $set: { OTP: OTP } });

  // Return a message to enter the OTP
  res.send({ message: "OTP sent. Please check your email." });
});

// Verify OTP Route
app.post("/verifyotp", async (req, res) => {
  // Check if the OTP is correct
  let user = await client.db("test").collection("users").findOne({ email: req.body.email, OTP: req.body.OTP });
  if (!user) {
    return res.status(400).send({ message: "OTP incorrect" });
  }

  // Remove the OTP from the database
  await client.db("test").collection("users").updateOne({ email: req.body.email }, { $unset: { OTP: "" } });

  // Generate a JWT token
  let token = jwt.sign({ email: req.body.email }, "<secret>", { expiresIn: "1h" });

  // Return the JWT token
  res.send({ message: "OTP verified", token: token });
});
